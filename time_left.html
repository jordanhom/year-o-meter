<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Countdown to New Year</title>
    <style>
    /* --- Base Styles --- */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: system-ui, sans-serif;
      background: #f8f9fa; /* Light grey background */
      color: #333; /* Darker text */
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      transition: background 0.3s; /* Smooth background transition */
    }
    .container {
      text-align: center;
      padding: 2rem 0 2rem 0;
      border-radius: 12px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.08);
      background: #ffffff; /* White container */
      min-width: 260px;
      max-width: 95vw; /* Responsive width */
      width: 100%;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      transition: background 0.3s, box-shadow 0.3s; /* Smooth transitions */
    }

    /* --- Seasonal Container Backgrounds --- */
    .container.season-spring { background: #eafff4; }
    .container.season-summer { background: #fffbe6; }
    .container.season-autumn { background: #fff6ea; }
    .container.season-winter { background: #eef7fb; }

    /* --- Date/Time Display --- */
    .datetime-wrap {
      margin-bottom: 1.2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25em;
      width: 100%;
      border-radius: 0; /* Full width */
      background: #e9f1fc; /* Light blue background */
      border-bottom: 3px solid #a8c5e9; /* Accent border */
      padding: 1.1em 0;
      box-shadow: 0 0.5px 2px rgba(58,110,165,0.05);
      font-weight: 600;
      transition: background 0.3s, border-color 0.3s;
    }
    /* Seasonal Date/Time Backgrounds */
    .container.season-spring .datetime-wrap { background: #dbffe6; border-bottom-color: #7bcfa5; }
    .container.season-summer .datetime-wrap { background: #fff7c2; border-bottom-color: #e6d36a; }
    .container.season-autumn .datetime-wrap { background: #ffe5ce; border-bottom-color: #e6a86a; }
    .container.season-winter .datetime-wrap { background: #e5f1fa; border-bottom-color: #8cbbe6; }

    .date-line, .time-line {
      font-size: 1.35rem;
      font-variant-numeric: tabular-nums; /* Keep numbers aligned */
      letter-spacing: 0.02em;
      color: #2c5aa3; /* Primary blue text */
      font-weight: bold;
      text-shadow: 0 1px 2px #fff; /* Subtle text shadow */
      width: 100%;
      display: block;
      text-align: center;
    }
    .date-line {
      font-size: 1.5rem; /* Larger date */
      font-weight: 700;
    }

    /* --- Title --- */
    .title {
      font-size: 1.5rem;
      margin-bottom: 1.2rem;
      font-weight: 500;
      color: #444; /* Dark grey */
    }

    /* --- Progress Bar & Countdown Container --- */
    .progress-bar-outer {
      position: relative; /* For positioning inner bar and countdown */
      width: 100%;
      height: 76px;
      margin: 0 auto 0.5em auto;
      background: #eef1f5; /* Light grey track */
      border-radius: 0;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      display: flex; /* Center countdown text */
      align-items: center;
      justify-content: center;
      max-width: 600px; /* Limit width */
      transition: background 0.3s;
    }
    /* Seasonal Progress Bar Backgrounds */
    .container.season-spring .progress-bar-outer { background: #b6e9ce; }
    .container.season-summer .progress-bar-outer { background: #fff6c0; }
    .container.season-autumn .progress-bar-outer { background: #ffe3c0; }
    .container.season-winter .progress-bar-outer { background: #d1e7f7; }

    .progress-bar-inner {
      position: absolute;
      left: 0; top: 0; bottom: 0;
      width: 0; /* Width controlled by JS */
      background: linear-gradient(90deg, #4a90e2 0%, #7aaee8 100%); /* Blue gradient */
      border-radius: 0;
      /* Smooth width transition, bouncy effect */
      transition: width 0.2s cubic-bezier(.4,2,.4,1), background 0.3s;
      z-index: 1; /* Below countdown text */
    }
    /* Seasonal Progress Bar Inner Gradients */
    .container.season-spring .progress-bar-inner { background: linear-gradient(90deg,#8ceabb 0%,#378f6d 100%); }
    .container.season-summer .progress-bar-inner { background: linear-gradient(90deg,#ffe259 0%,#ffa751 100%); }
    .container.season-autumn .progress-bar-inner { background: linear-gradient(90deg,#ffb347 0%,#ff6c3a 100%); }
    .container.season-winter .progress-bar-inner { background: linear-gradient(90deg,#a1c4fd 0%,#c2e9fb 100%); }

    /* --- Countdown Text (Overlay) --- */
    .countdown {
      position: relative; /* Position above progress bar */
      z-index: 2; /* Above progress bar */
      width: 100%;
      display: flex;
      flex-wrap: wrap; /* Allow wrapping on small screens */
      justify-content: center;
      gap: 2.1rem; /* Space between units */
      font-size: 2.2rem;
      font-variant-numeric: tabular-nums; /* Keep numbers aligned */
      font-weight: 700;
      user-select: none; /* Prevent text selection */
      padding: 0 1.2rem;
      color: #fff; /* White text */
      text-shadow: /* Enhance readability */
        0 2px 6px rgba(0,0,0,0.35),
        0 0px 1px rgba(0,0,0,0.5);
      pointer-events: none; /* Allow clicks through to progress bar if needed */
    }
    .unit {
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 70px; /* Ensure some spacing */
    }
    .number {
      font-size: 2.2rem;
      font-weight: 700;
      letter-spacing: 0.02em;
    }
    .label {
      font-size: 1.08rem;
      font-weight: 600;
      margin-top: 0.22em;
      letter-spacing: 0.01em;
      color: #fff;
      text-shadow: /* Enhance readability */
        0 1px 4px rgba(0,0,0,0.25),
        0 0.5px 1px rgba(0,0,0,0.4);
      background: rgba(0, 0, 0, 0.2); /* Semi-transparent background */
      border-radius: 4px;
      padding: 0.06em 0.4em;
      transition: color 0.2s, background 0.2s;
      line-height: 1.2;
      box-decoration-break: clone; box-decoration-break: clone; /* Ensures background/padding apply correctly if label wraps lines */
    }
    /* Style labels differently when progress bar is nearly empty */
    .countdown.low-progress .label {
      color: #2c5aa3; /* Use primary blue text */
      background: rgba(255,255,255,0.75); /* Light background */
      text-shadow: 0 1px 3px #fff;
    }

    /* --- Year Grid Component --- */
    .year-grid-component {
      margin: 2.2rem auto 0 auto;
      width: 479px; /* Fixed width based on grid cells */
      max-width: 100vw;
      min-width: 238px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
    }
    /* Responsive adjustments for smaller screens */
    @media (max-width: 500px) {
      .year-grid-component {
        width: 100vw;
        min-width: 0;
        padding: 0 2vw;
      }
      .year-grid {
        /* Allow grid to shrink on very small screens */
        width: 100vw;
        min-width: 0;
        max-width: 100vw;
      }
    }
    .year-grid {
      display: grid;
      /* Define grid columns and rows */
      grid-template-columns: repeat(30, 15px);
      grid-template-rows: repeat(13, 15px);
      gap: 1px; /* Space between blocks */
      width: 479px; /* 30 columns * 15px width + 29 gaps * 1px */
      max-width: 100vw;
      background: #eef1f5; /* Match progress bar track */
      border-radius: 0;
      margin: 0;
      box-sizing: border-box;
      overflow: hidden; /* Hide overflow if any */
      justify-items: center; /* Center blocks horizontally */
      align-items: center; /* Center blocks vertically */
      transition: background 0.3s;
    }
    /* Seasonal Grid Backgrounds */
    .container.season-spring .year-grid { background: #b6e9ce; }
    .container.season-summer .year-grid { background: #fff6c0; }
    .container.season-autumn .year-grid { background: #ffe3c0; }
    .container.season-winter .year-grid { background: #d1e7f7; }

    /* Individual day block styling */
    .day-block {
      width: 15px;
      height: 15px;
      background: #ffffff; /* Default/Future blocks are white */
      border-radius: 0; /* Default square */
      transition: background 0.18s, border 0.18s, border-radius 0.2s;
      box-sizing: border-box;
      border: 0.5px solid #dde2e8; /* Light border */
      display: block;
      outline: none; /* Remove default browser outline */
    }
    /* Style for circle grid option */
    .year-grid.circles .day-block {
      border-radius: 50%;
    }
    /* Seasonal colors for past/future/today blocks */
    .container.season-spring .day-block.past { background: #7bcfa5; }
    .container.season-summer .day-block.past { background: #ffe259; }
    .container.season-autumn .day-block.past { background: #ffb347; }
    .container.season-winter .day-block.past { background: #a1c4fd; }
    .container.season-spring .day-block.future { background: #eafff4; }
    .container.season-summer .day-block.future { background: #fffbe6; }
    .container.season-autumn .day-block.future { background: #fff6ea; }
    .container.season-winter .day-block.future { background: #f6faff; }
    .container.season-spring .day-block.today { background: #34e89e; border-color: #0a8d49; }
    .container.season-summer .day-block.today { background: #ffe259; border-color: #ffb347; }
    .container.season-autumn .day-block.today { background: #ffb347; border-color: #d97f22; }
    .container.season-winter .day-block.today { background: #a1c4fd; border-color: #3a6ea5; }

    /* Default colors for past/today/future blocks */
    .day-block.past {
      background: #a8c5e9; /* Light blue */
    }
    .day-block.today {
      background: #4a90e2; /* Primary blue */
      border: 2px solid #2c5aa3; /* Darker blue border */
      box-shadow: 0 0 0 2px #fff, 0 2px 8px rgba(58,110,165,0.15); /* Highlight effect */
      position: relative; /* Ensure it's above others if overlapping */
      z-index: 2;
    }
    .day-block.future {
      background: #ffffff; /* White */
    }
    /* Style for unused blocks at the end of the grid */
    .day-block.overflow {
      background: transparent;
      border: none;
      pointer-events: none;
      visibility: hidden;
    }
    /* Special day markers (use !important to override seasonal/past/today styles) */
    .day-block.holiday {
      background: #e84a5f !important; /* Red */
      border-color: #e84a5f !important;
      box-shadow: 0 0 0 1.5px #fff; /* White outline */
    }
    .day-block.longest-day {
      background: #4bd865 !important; /* Green */
      border-color: #3fa855 !important;
      box-shadow: 0 0 0 1.5px #fff;
    }
    .day-block.shortest-day {
      background: #3a6ea5 !important; /* Darker blue */
      border-color: #1a2a44 !important;
      box-shadow: 0 0 0 1.5px #fff;
    }
    /* Accessibility: Style for keyboard focus */
    .day-block:focus-visible {
      outline: 2px solid #6a54d4; /* Purple outline */
      outline-offset: 0;
    }

    /* --- Extra Options Section --- */
    .extra-options-section {
      width: 100%;
      max-width: 400px; /* Limit width */
      margin: 1.6em auto 0 auto;
      background: #fcfdff; /* Very light background */
      border: 1px solid #cdd9e8; /* Light border */
      border-radius: 7px;
      box-shadow: 0 2px 6px rgba(228, 231, 237, 0.7); /* Soft shadow */
      transition: box-shadow 0.2s;
      overflow: hidden; /* Needed for collapse transition */
    }
    .extra-options-header {
      display: flex;
      align-items: center;
      cursor: pointer;
      font-size: 1.13em;
      font-weight: 600;
      color: #2c5aa3; /* Primary blue */
      padding: 0.7em 1.2em;
      user-select: none; /* Prevent text selection */
      background: #f0f6ff; /* Light blue header background */
      border: none;
      outline: none;
      width: 100%;
      transition: background 0.12s;
    }
    .extra-options-header:focus, .extra-options-header:hover {
      background: #e9f1fc; /* Slightly darker on hover/focus */
    }
    .carrot { /* The '>' icon */
      font-size: 1.15em;
      display: inline-block;
      transition: transform 0.2s; /* Animate rotation */
      margin-right: 0.4em;
    }
    .carrot.open {
      transform: rotate(90deg); /* Point down when open */
    }
    .features-toggles { /* Container for checkboxes */
      display: flex;
      flex-direction: column;
      align-items: flex-start; /* Align checkboxes left */
      gap: 0.8em;
      width: 100%;
      padding: 0 1.4em 0.8em 1.4em;
      font-size: 1.07em;
      background: transparent;
      border: none;
      box-shadow: none;
      opacity: 1;
      max-height: 1000px; /* Allow space for content */
      overflow: visible;
      /* Smooth collapse/expand animation */
      transition: max-height 0.32s cubic-bezier(.5,0,.5,1), opacity 0.25s;
    }
    .features-toggles.collapsed {
      opacity: 0;
      max-height: 0; /* Collapse */
      padding-bottom: 0 !important; /* Remove padding when collapsed */
      pointer-events: none; /* Prevent interaction when collapsed */
      overflow: hidden;
    }
    .toggle-block { /* Wrapper for checkbox + label */
      display: flex;
      align-items: center;
      gap: 0.4em;
      color: #555; /* Grey text */
      user-select: none;
      font-weight: 500;
      margin-top: 0.1em;
    }
    .toggle-block label {
      cursor: pointer;
      opacity: 0.88; /* Slightly faded */
    }
    /* Style disabled options */
    .toggle-block input[type="checkbox"]:disabled + label {
      opacity: 0.45 !important;
      cursor: not-allowed;
    }
    .toggle-block input[type="checkbox"]:disabled {
      filter: grayscale(1) opacity(0.6);
      pointer-events: none;
    }
    .features-toggles hr { /* Separator line */
      width: 100%;
      border: 0.5px solid #dde2e8; /* Light grey line */
      margin: 0.6em 0;
    }
    /* Indent options related to the grid */
    .grid-options-group {
      margin-left: 1.6em;
      display: flex;
      flex-direction: column;
      gap: 0.45em;
    }

    /* --- Responsive Media Queries --- */
    @media (max-width: 600px) {
      /* Adjust options section width */
      .extra-options-section {
        min-width: 0;
        max-width: 98vw;
      }
      /* Adjust toggle font size and padding */
      .features-toggles {
        font-size: 1em;
        padding: 0 0.8em 0.5em 0.8em;
      }
      /* Ensure grid component takes full width */
      .year-grid-component, .year-grid {
        width: 100vw;
        min-width: 0;
        padding: 0 1vw;
        max-width: 100vw;
      }
      /* Explicitly set grid width again inside media query */
      .year-grid {
        width: 100vw;
        min-width: 0;
        max-width: 100vw;
      }
    }
  </style>
</head>
<body>
  <div class="container" id="main-container">
    <!-- Current Date and Time Display -->
    <div class="datetime-wrap" id="prominent-datetime">
      <span class="date-line" id="date-line"></span>
      <span class="time-line" id="time-line"></span>
    </div>

    <!-- Countdown Title -->
    <div class="title">Time remaining this year</div>

    <!-- Progress Bar and Countdown Overlay -->
    <div class="progress-bar-outer">
      <div class="progress-bar-inner" id="progress"></div>
      <div class="countdown" id="countdown"></div>
    </div>

    <!-- Year Grid (Initially Hidden) -->
    <div class="year-grid-component" id="year-grid-component" style="display:none;">
      <div class="year-grid" id="year-grid"></div>
    </div>

    <!-- Collapsible Extra Options Section -->
    <section class="extra-options-section" id="extra-options-section">
      <!-- Button to toggle the options panel -->
      <!-- Accessibility: aria-expanded indicates state -->
      <!-- Accessibility: aria-controls links to controlled element -->
      <button type="button"
        class="extra-options-header"
        id="extra-options-toggle"
        aria-expanded="false"
        aria-controls="features-toggles">
        <span class="carrot" id="carrot">&#9654;</span> <!-- Right-pointing triangle icon -->
        <span>Extra Options…</span>
      </button>
      <!-- Container for the actual toggles -->
      <!-- Accessibility: aria-hidden indicates state -->
      <div class="features-toggles collapsed" id="features-toggles" aria-hidden="true">
        <!-- Milliseconds Toggle -->
        <div class="toggle-block">
          <input type="checkbox" id="toggle-ms" />
          <label for="toggle-ms">Show milliseconds</label>
        </div>
        <!-- Seasonal Styling Toggle -->
        <div class="toggle-block">
          <input type="checkbox" id="toggle-season" />
          <label for="toggle-season">Style for current season</label>
        </div>
        <hr> <!-- Separator -->
        <!-- Year Grid Toggle -->
        <div class="toggle-block">
          <input type="checkbox" id="toggle-grid" />
          <label for="toggle-grid"><b>Show year grid</b></label>
        </div>
        <!-- Options dependent on the year grid being visible -->
        <div class="grid-options-group">
          <div class="toggle-block">
            <input type="checkbox" id="toggle-circles" disabled /> <!-- Initially disabled -->
            <label for="toggle-circles">Use circles for grid</label>
          </div>
          <div class="toggle-block">
            <input type="checkbox" id="toggle-holidays" disabled /> <!-- Initially disabled -->
            <label for="toggle-holidays">Show holidays</label>
          </div>
          <div class="toggle-block">
            <input type="checkbox" id="toggle-solstice" disabled /> <!-- Initially disabled -->
            <label for="toggle-solstice">Show longest/shortest day</label>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    // --- State Variables ---
    // These variables control the application's features and are toggled by the checkboxes.
    let showMilliseconds = false; // Display milliseconds in countdown/time?
    let showGrid = false;         // Display the year grid visualization?
    let showCircles = false;      // Use circles instead of squares in the grid?
    let showHolidays = false;     // Highlight holidays on the grid?
    let showSolstice = false;     // Highlight solstice days on the grid?
    let styleSeason = false;      // Apply seasonal color themes?

    // --- Grid Rendering Optimization Variables ---
    let currentYearGridRendered = null; // Tracks the year the grid DOM was last built for. Avoids rebuilding unnecessarily.
    let dayBlockElements = [];          // Stores references to the created grid cell DOM elements for quick updates.

    // --- DOM Element References ---
    // Get references to frequently used elements upfront for performance.
    const checkboxMs = document.getElementById('toggle-ms');
    const checkboxGrid = document.getElementById('toggle-grid');
    const checkboxCircles = document.getElementById('toggle-circles');
    const checkboxHolidays = document.getElementById('toggle-holidays');
    const checkboxSolstice = document.getElementById('toggle-solstice');
    const checkboxSeason = document.getElementById('toggle-season');
    const gridWrap = document.getElementById('year-grid-component'); // The container for the grid
    const gridEl = document.getElementById('year-grid');             // The grid element itself
    const container = document.getElementById('main-container');     // The main page container for seasonal styling

    // --- Initialization ---
    // Set the initial state of checkboxes to match the default state variables.
    checkboxMs.checked = showMilliseconds;
    checkboxSeason.checked = styleSeason;
    checkboxGrid.checked = showGrid;
    checkboxCircles.checked = showCircles;
    checkboxHolidays.checked = showHolidays;
    checkboxSolstice.checked = showSolstice;

    /**
     * Enables or disables grid-specific option checkboxes based on whether the grid is shown.
     * Also resets the state of dependent options if the grid is hidden.
     */
    function updateGridOptionStates() {
      const gridIsEnabled = showGrid;
      checkboxCircles.disabled = !gridIsEnabled;
      checkboxHolidays.disabled = !gridIsEnabled;
      checkboxSolstice.disabled = !gridIsEnabled;

      // If grid is turned off, uncheck and reset state for dependent options
      if (!gridIsEnabled) {
        checkboxCircles.checked = false;
        checkboxHolidays.checked = false;
        checkboxSolstice.checked = false;
        showCircles = false;
        showHolidays = false;
        showSolstice = false;
      }
    }
    // Run once on load to set initial disabled states.
    updateGridOptionStates();

    // --- Update Interval Management ---
    let updateInterval = 200; // Default update frequency (milliseconds)
    let intervalId = null;    // Stores the ID returned by setInterval

    /**
     * Sets or resets the main update interval timer (`setInterval`).
     * Uses a faster interval (50ms) if milliseconds are shown, otherwise slower (200ms).
     */
    function setupUpdateInterval() {
        if (intervalId) clearInterval(intervalId); // Clear any existing interval first
        updateInterval = showMilliseconds ? 50 : 200; // Adjust speed based on option
        intervalId = setInterval(renderAll, updateInterval); // Start the new interval
        // console.log(`Interval set to ${updateInterval}ms`); // Optional debug log
    }

    // --- Event Listeners for Options ---

    // Listener for Milliseconds toggle
    checkboxMs.addEventListener('change', function() {
        showMilliseconds = this.checked; // Update state variable
        setupUpdateInterval();           // Adjust timer speed
        renderAll();                     // Re-render immediately with new setting
    });

    // Listener for Seasonal Styling toggle
    checkboxSeason.addEventListener('change', function() {
      styleSeason = this.checked; // Update state variable
      applySeasonStyle();         // Apply/remove seasonal CSS classes
      renderAll();                // Re-render (mainly for grid colors if shown)
    });

    // Listener for Year Grid toggle
    checkboxGrid.addEventListener('change', function() {
      showGrid = this.checked;          // Update state variable
      updateGridOptionStates();       // Enable/disable dependent options
      // Force the grid structure to be rebuilt next time renderAll runs,
      // because visibility changed or dependent options might reset.
      currentYearGridRendered = null;
      renderAll();                    // Re-render (shows/hides grid, updates dependent options)
    });

    // Listener for Grid Circles toggle
    checkboxCircles.addEventListener('change', function() {
      showCircles = this.checked; // Update state variable
      // Force grid rebuild because the 'circles' class needs to be added/removed
      // at the grid container level, affecting all blocks.
      currentYearGridRendered = null;
      renderAll();                // Re-render grid
    });

    // Listener for Holidays toggle
    checkboxHolidays.addEventListener('change', function() {
      showHolidays = this.checked; // Update state variable
      // No need to rebuild grid structure, just update styles.
      renderAll();                 // Re-render grid to apply/remove holiday class
    });

    // Listener for Solstice toggle
    checkboxSolstice.addEventListener('change', function() {
      showSolstice = this.checked; // Update state variable
      // No need to rebuild grid structure, just update styles.
      renderAll();                 // Re-render grid to apply/remove solstice classes
    });

    // --- Extra Options Panel Logic ---
    const extraOptionsToggle = document.getElementById("extra-options-toggle");
    const carrot = document.getElementById("carrot");
    const featuresToggles = document.getElementById("features-toggles");
    let optionsOpen = false; // State for the collapsible panel

    /**
     * Toggles the visibility of the extra options panel and updates ARIA attributes.
     */
    function toggleOptionsPanel() {
      optionsOpen = !optionsOpen;
      // Toggle CSS classes for visual state and animation
      featuresToggles.classList.toggle("collapsed", !optionsOpen);
      carrot.classList.toggle("open", optionsOpen);
      // Update ARIA attributes for accessibility
      extraOptionsToggle.setAttribute("aria-expanded", optionsOpen ? "true" : "false");
      featuresToggles.setAttribute("aria-hidden", optionsOpen ? "false" : "true");
    }
    // Toggle panel on button click
    extraOptionsToggle.addEventListener("click", toggleOptionsPanel);
    // Toggle panel on Space or Enter key press for accessibility
    extraOptionsToggle.addEventListener("keydown", function(e) {
      if (e.key === " " || e.key === "Enter") {
        e.preventDefault(); // Prevent default button action (like scrolling)
        toggleOptionsPanel();
      }
    });

    // --- Seasonal Styling Logic ---

    /**
     * Determines the current season based on the date and locale (basic hemisphere detection).
     * @param {Date} [date=new Date()] - The date to check.
     * @param {string} [locale=navigator.language] - The browser locale (e.g., 'en-US', 'en-AU').
     * @returns {string} The season ('spring', 'summer', 'autumn', 'winter').
     */
    function getSeason(date = new Date(), locale = navigator.language) {
      const month = date.getMonth(); // 0-11
      // Very basic check for Southern Hemisphere locales
      const southernLocales = ['AU','NZ','ZA','AR','BR','CL','UY','PY','BO','PE','EC'];
      let isSouthern = southernLocales.some(code => locale.toUpperCase().includes('-' + code));

      // Determine season based on month (adjusting for hemisphere)
      // Note: These are meteorological season approximations (Dec-Feb = Winter/Summer, etc.)
      if (!isSouthern) { // Northern Hemisphere
        if (month >= 2 && month <= 4) return 'spring';  // Mar, Apr, May
        if (month >= 5 && month <= 7) return 'summer';  // Jun, Jul, Aug
        if (month >= 8 && month <= 10) return 'autumn'; // Sep, Oct, Nov
        return 'winter'; // Dec, Jan, Feb
      } else { // Southern Hemisphere
        if (month >= 2 && month <= 4) return 'autumn';
        if (month >= 5 && month <= 7) return 'winter';
        if (month >= 8 && month <= 10) return 'spring';
        return 'summer';
      }
    }

    /**
     * Applies the appropriate seasonal CSS class to the main container element.
     * Removes existing season classes first.
     */
    function applySeasonStyle() {
      // Remove all possible season classes first
      container.classList.remove('season-spring','season-summer','season-autumn','season-winter');
      // Add the current season class if the option is enabled
      if (styleSeason) {
        const season = getSeason();
        container.classList.add('season-' + season);
      }
    }

    // --- Time & Progress Calculation Functions ---

    /**
     * Calculates the time remaining until the end of the current year.
     * @returns {object} Object containing days, hours, minutes, seconds, milliseconds remaining.
     */
    function getTimeRemaining() {
      const now = new Date();
      const year = now.getFullYear();
      // Target is the very end of the last day of the year
      const endOfYear = new Date(year, 11, 31, 23, 59, 59, 999);
      let diff = endOfYear - now; // Difference in milliseconds

      // Handle edge case where calculation might be slightly negative right at year change
      if (diff < 0) diff = 0;

      // Calculate individual units
      const ms = diff % 1000;
      diff = Math.floor(diff / 1000); // Convert to seconds
      const s = diff % 60;
      diff = Math.floor(diff / 60); // Convert to minutes
      const m = diff % 60;
      diff = Math.floor(diff / 60); // Convert to hours
      const h = diff % 24;
      const d = Math.floor(diff / 24); // Full days remaining

      return { days: d, hours: h, minutes: m, seconds: s, milliseconds: ms };
    }

    /**
     * Calculates the percentage of the current year that has elapsed.
     * @returns {number} Percentage (0-100).
     */
    function getYearProgressPercent() {
      const now = new Date();
      const year = now.getFullYear();
      const startOfYear = new Date(year, 0, 1, 0, 0, 0, 0); // Start of Jan 1st
      const endOfYear = new Date(year, 11, 31, 23, 59, 59, 999); // End of Dec 31st
      const elapsed = now - startOfYear; // Milliseconds elapsed since start of year
      const total = endOfYear - startOfYear; // Total milliseconds in the year

      let percent = (elapsed / total) * 100;

      // Clamp percentage between 0 and 100
      if (percent < 0) percent = 0;
      if (percent > 100) percent = 100;

      return percent;
    }

    /**
     * Helper function to pad a number with leading zeros.
     * @param {number} n - The number to pad.
     * @param {number} [width=2] - The desired minimum width.
     * @returns {string} The padded number as a string.
     */
    function pad(n, width = 2) {
      return n.toString().padStart(width, '0');
    }

    // --- UI Rendering Functions ---

    /**
     * Updates the countdown display (Days, Hours, Minutes, Seconds, optional Milliseconds).
     */
    function renderCountdown() {
      const t = getTimeRemaining();
      // Prepare the HTML string for the milliseconds unit (only added if showMilliseconds is true)
      let msUnit = `
        <div class="unit ms"><span class="number">${pad(t.milliseconds, 3)}</span><span class="label">ms</span></div>
      `;
      // Main HTML structure for the countdown units
      // Conditionally include milliseconds unit based on showMilliseconds flag
      let html = `
        <div class="unit"><span class="number">${t.days}</span><span class="label">Days</span></div>
        <div class="unit"><span class="number">${pad(t.hours)}</span><span class="label">Hours</span></div>
        <div class="unit"><span class="number">${pad(t.minutes)}</span><span class="label">Minutes</span></div>
        <div class="unit"><span class="number">${pad(t.seconds)}</span><span class="label">Seconds</span></div>
        ${showMilliseconds ? msUnit : ''}
      `;
      // Update the DOM
      document.getElementById('countdown').innerHTML = html;
    }

    /**
     * Updates the current date and time display. Uses Intl.DateTimeFormat for robust formatting,
     * especially when including milliseconds.
     */
    function renderDateTime() {
        const now = new Date();
        // Format the date (e.g., "October 26, 2023")
        const dateStr = now.toLocaleDateString(undefined, { // 'undefined' uses browser default locale
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
        // Determine user locale, fallback to 'en-US'
        const userLocale = navigator.language || 'en-US';

        let timeStr;
        if (showMilliseconds) {
            // Use Intl.DateTimeFormat for reliable time formatting with milliseconds
            try {
              timeStr = new Intl.DateTimeFormat(userLocale, {
                  hour: 'numeric', // e.g., 1, 11
                  minute: '2-digit', // e.g., 05, 59
                  second: '2-digit', // e.g., 08, 45
                  fractionalSecondDigits: 3, // Include milliseconds (e.g., .123)
                  hour12: true // Use AM/PM (can be set based on locale or preference)
              }).format(now);
            } catch (e) {
              // Fallback if Intl or fractionalSecondDigits isn't fully supported
              console.warn("Intl.DateTimeFormat with fractionalSecondDigits might not be fully supported. Falling back.", e);
              const basicTimeStr = now.toLocaleTimeString(); // Get basic time string
              const ms = now.getMilliseconds().toString().padStart(3, '0');
              // Attempt to insert ms before AM/PM using regex (less reliable)
              timeStr = basicTimeStr.replace(/(:\d{2})(?!.*:\d{2})/, `$1.${ms}`);
              // If regex failed (e.g., different locale format), just append ms
              if (timeStr === basicTimeStr) {
                 timeStr += `.${ms}`;
              }
            }
        } else {
            // Get standard time string without milliseconds
            timeStr = now.toLocaleTimeString();
        }

        // Update the DOM elements
        document.getElementById('date-line').textContent = dateStr;
        document.getElementById('time-line').textContent = timeStr;
    }

    /**
     * Updates the width of the progress bar and applies/removes the 'low-progress'
     * class to the countdown text for styling adjustments.
     */
    function renderProgress() {
      const percent = getYearProgressPercent();
      const progressBar = document.getElementById('progress');
      const countdown = document.getElementById('countdown'); // The text overlay element

      // Set the width style of the inner progress bar
      progressBar.style.width = percent + '%';

      // Add a class to the countdown text when progress is low (e.g., < 10%)
      // This allows styling the labels differently (e.g., making them lighter).
      if (percent < 10) {
        countdown.classList.add('low-progress');
      } else {
        countdown.classList.remove('low-progress');
      }
    }

    // --- Holiday & Solstice Data Functions ---

    /**
     * Generates a list of major US holidays for a given year.
     * Includes fixed dates and calculated dates (e.g., Nth weekday of a month).
     * @param {number} year - The year for which to calculate holidays.
     * @returns {Array<object>} An array of holiday objects {month, day, name}.
     */
    function getHolidays(year) {
      /**
       * Helper to find the date of the Nth specific weekday within a given month and year.
       * @param {number} n - The occurrence (1-4 for 1st-4th, 5 for *last*).
       * @param {number} weekday - The target day of the week (0=Sun, 1=Mon, ..., 6=Sat).
       * @param {number} month - The target month (0=Jan, ..., 11=Dec).
       * @param {number} year - The target year.
       * @returns {number|null} The day of the month (1-31), or null if not found.
       */
      function findNthWeekdayOfMonth(n, weekday, month, year) {
        const date = new Date(year, month, 1); // Start at the 1st of the month
        let count = 0; // How many times we've found the target weekday
        let dayOfMonth = null;

        if (n === 5) { // Special case: Find the *last* occurrence
          date.setMonth(date.getMonth() + 1); // Go to the 1st day of the *next* month
          date.setDate(0); // Go back one day to the *last* day of the target month
          // Now, go backwards from the end of the month until we hit the target weekday
          while (date.getDay() !== weekday) {
            date.setDate(date.getDate() - 1);
          }
          return date.getDate(); // Return the date of that last occurrence
        } else { // Find the Nth (1st, 2nd, 3rd, or 4th) occurrence
          // Loop through the days of the month
          while (date.getMonth() === month) { // Ensure we stay within the target month
            if (date.getDay() === weekday) { // Check if the current day is the target weekday
              count++; // Increment the count if it is
              if (count === n) { // If this is the Nth occurrence we're looking for...
                dayOfMonth = date.getDate(); // Store the date
                break; // Found it, exit the loop
              }
            }
            date.setDate(date.getDate() + 1); // Move to the next day
          }
          return dayOfMonth; // Return the found date, or null if not found (e.g., 5th Monday in Feb)
        }
      }

      // Define fixed-date holidays
      const holidays = [
        { month: 0, day: 1, name: "New Year's Day" },     // Jan 1
        { month: 5, day: 19, name: "Juneteenth" },        // June 19
        { month: 6, day: 4, name: "Independence Day" },  // July 4
        { month: 10, day: 11, name: "Veterans Day" },     // Nov 11
        { month: 11, day: 25, name: "Christmas Day" }     // Dec 25
      ];

      // Calculate holidays based on weekday occurrences
      const mlkDay = findNthWeekdayOfMonth(3, 1, 0, year); // 3rd Monday in Jan
      if (mlkDay) holidays.push({ month: 0, day: mlkDay, name: "Martin Luther King Jr. Day" });

      const presidentsDay = findNthWeekdayOfMonth(3, 1, 1, year); // 3rd Monday in Feb
      if (presidentsDay) holidays.push({ month: 1, day: presidentsDay, name: "Presidents' Day" });

      const memorialDay = findNthWeekdayOfMonth(5, 1, 4, year); // Last Monday in May
      if (memorialDay) holidays.push({ month: 4, day: memorialDay, name: "Memorial Day" });

      const laborDay = findNthWeekdayOfMonth(1, 1, 8, year); // 1st Monday in Sep
      if (laborDay) holidays.push({ month: 8, day: laborDay, name: "Labor Day" });

      const columbusDay = findNthWeekdayOfMonth(2, 1, 9, year); // 2nd Monday in Oct
      if (columbusDay) holidays.push({ month: 9, day: columbusDay, name: "Columbus Day" });

      const thanksgivingDay = findNthWeekdayOfMonth(4, 4, 10, year); // 4th Thursday in Nov
      if (thanksgivingDay) holidays.push({ month: 10, day: thanksgivingDay, name: "Thanksgiving Day" });

      // Sort holidays by date (optional, but can be helpful)
      holidays.sort((a, b) => {
        if (a.month !== b.month) return a.month - b.month;
        return a.day - b.day;
      });

      return holidays;
    }

    /**
     * Returns approximate dates for the longest and shortest days of the year (solstices).
     * Note: Actual solstice dates vary slightly year to year. These are common approximations.
     * @param {number} year - The year.
     * @returns {object} Object containing Date objects for 'longest' and 'shortest' days.
     */
    function getSolsticeDays(year) {
      // Approximate longest day (Summer Solstice in Northern Hemisphere)
      let longest = new Date(year, 5, 21); // June 21
      // Approximate shortest day (Winter Solstice in Northern Hemisphere)
      let shortest = new Date(year, 11, 21); // Dec 21
      return { longest, shortest };
    }

    /**
     * Checks if a given year is a leap year.
     * @param {number} year - The year to check.
     * @returns {boolean} True if it's a leap year, false otherwise.
     */
    function isLeapYear(year) {
      // Leap year rules: Divisible by 4, unless divisible by 100 but not by 400.
      return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
    }

    // --- Year Grid Rendering ---

    /**
     * Renders the year grid visualization.
     * This function is optimized:
     * 1. It only builds the grid DOM elements once per year (or when options force it).
     * 2. On subsequent calls within the same year, it only updates the CSS classes and titles
     *    of the existing elements, which is much faster.
     */
    function renderYearGrid() {
        const now = new Date();
        const year = now.getFullYear();

        // --- 1. Check Visibility ---
        // If the grid shouldn't be shown, hide the container and exit early.
        if (!showGrid) {
            if (gridWrap.style.display !== "none") {
              gridWrap.style.display = "none"; // Hide if not already hidden
            }
            return; // Don't proceed further
        } else {
            // If grid should be shown, ensure the container is visible
            if (gridWrap.style.display === "none") {
              gridWrap.style.display = ""; // Show if hidden (restore default display)
            }
        }

        // --- 2. Build Grid Structure (if necessary) ---
        // Only rebuild the grid DOM if the year has changed or if an option
        // (like 'showGrid' or 'showCircles') requires a structural update.
        if (currentYearGridRendered !== year) {
            // console.log(`Grid structure rebuild needed for ${year}`); // Debug log
            gridEl.innerHTML = ''; // Clear any previous grid elements
            dayBlockElements = []; // Reset the stored element references
            const totalDays = isLeapYear(year) ? 366 : 365;
            const cols = 30; // Grid dimensions
            const rows = 13;
            let dayIndex = 0; // Track which day of the year we are creating

            // Create the grid cells (divs)
            for (let row = 0; row < rows; row++) {
              for (let col = 0; col < cols; col++) {
                  const gridCell = document.createElement('div');
                  gridCell.className = 'day-block'; // Assign base class

                  if (dayIndex < totalDays) {
                    // If this cell represents a valid day of the year, store its reference
                    dayBlockElements.push(gridCell);
                    dayIndex++;
                  } else {
                    // If this cell is beyond the number of days in the year, mark it as overflow
                    gridCell.classList.add('overflow');
                    gridCell.tabIndex = -1; // Make it non-focusable
                  }
                  gridEl.appendChild(gridCell); // Add the cell to the grid container
              }
            }
            currentYearGridRendered = year; // Mark that the grid has been built for this year
        }

        // --- 3. Update Styles and Attributes on Existing Elements ---
        // This part runs frequently to update the appearance of the grid cells.

        // Toggle the 'circles' class on the grid container based on the option
        gridEl.classList.toggle("circles", showCircles);

        // Calculate the current day of the year (0-indexed)
        const startOfYear = new Date(year, 0, 1);
        const dayOfYear = Math.floor((now - startOfYear) / (24 * 60 * 60 * 1000));

        // Get holiday and solstice data *once* before the loop if options are enabled
        const holidaysData = showHolidays ? getHolidays(year) : [];
        // Create efficient ways to check for holidays/solstices
        const holidayMap = showHolidays ? new Map(holidaysData.map(h => [(new Date(year, h.month, h.day)).toDateString(), h.name])) : null;
        const solstice = showSolstice ? getSolsticeDays(year) : {};
        const longestDayStr = showSolstice && solstice.longest ? solstice.longest.toDateString() : null;
        const shortestDayStr = showSolstice && solstice.shortest ? solstice.shortest.toDateString() : null;

        // Loop through the stored day block elements and update their classes and titles
        dayBlockElements.forEach((gridCell, index) => {
            const dayIndex = index; // The 0-based index corresponds to the day of the year
            const date = new Date(year, 0, 1 + dayIndex); // Get the Date object for this day
            const dateStr = date.toDateString(); // Get a comparable string representation (e.g., "Thu Oct 26 2023")
            // Get a locale-friendly string for the tooltip
            const dateLocaleStr = date.toLocaleDateString(undefined, {weekday:'short', month:'short', day:'numeric', year:'numeric'});

            // Reset dynamic classes first
            gridCell.classList.remove('past', 'today', 'future', 'holiday', 'longest-day', 'shortest-day');
            let title = dateLocaleStr; // Default tooltip text

            // Apply the appropriate class(es) based on the day's status
            if (showHolidays && holidayMap.has(dateStr)) {
              gridCell.classList.add('holiday');
              title += ' — ' + holidayMap.get(dateStr); // Add holiday name to tooltip
            } else if (showSolstice && longestDayStr === dateStr) {
              gridCell.classList.add('longest-day');
              title += ' — Longest Day';
            } else if (showSolstice && shortestDayStr === dateStr) {
              gridCell.classList.add('shortest-day');
              title += ' — Shortest Day';
            } else {
              // If not a special day, mark as past, today, or future
              if (dayIndex < dayOfYear) {
                gridCell.classList.add('past');
              } else if (dayIndex === dayOfYear) {
                gridCell.classList.add('today');
              } else {
                gridCell.classList.add('future');
              }
            }
            // Update the tooltip (title attribute) for the cell
            gridCell.title = title;
        });
    }

    // --- Main Render Loop ---

    /**
     * Main function called repeatedly by setInterval to update all dynamic UI elements.
     */
    function renderAll() {
      applySeasonStyle(); // Update seasonal styles if needed
      renderDateTime();   // Update current date/time display
      renderCountdown();  // Update countdown timer
      renderProgress();   // Update progress bar
      renderYearGrid();   // Update year grid (efficiently)
    }

    // --- Initial Setup ---
    setupUpdateInterval(); // Set the initial update interval based on default options
    renderAll();           // Call renderAll once immediately to populate the UI on load
                           // without waiting for the first interval tick.

  </script>
</body>
</html>
